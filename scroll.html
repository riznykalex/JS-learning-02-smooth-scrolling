<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>Скрол в js</title>
</head>
<style>
    body{
        height:2000px;
    }
    div{
        margin:100px;
        height:200px;
        overflow:auto;
        border:1px solid #000;
    }
    .scrollTop{
        position:fixed;
        right:20px;
        bottom:20px;
        cursor:pointer;
        height:20px;
    }
</style>

<script>

    /*
document.querySelector('.scrollTop').addEventListener('click', function(){
    var scrolled = window.pageYOffset;
    scrollTop(scrolled,1);
});

function scrollTop(endPos,i){
    setTimeout(function(){
        if(parseInt(endPos) > 0) {
            var y = parseInt(endPos) - 5 * parseInt(i);
            window.scroll(0, y); //Устанавливаем новую позицию вертикального скрола
            scrollTop(y,parseInt(i)+2);//Рекурсивный вызов функции
        }
    },10);

}

*/





function currentYPosition() {
    // Firefox, Chrome, Opera, Safari
    if (self.pageYOffset) return self.pageYOffset;
    // Internet Explorer 6 - standards mode
    if (document.documentElement && document.documentElement.scrollTop)
        return document.documentElement.scrollTop;
    // Internet Explorer 6, 7 and 8
    if (document.body.scrollTop) return document.body.scrollTop;
    return 0;
}


function elmYPosition(eID) {
    var elm = document.getElementById(eID);
    var y = elm.offsetTop;
    var node = elm;
    while (node.offsetParent && node.offsetParent != document.body) {
        node = node.offsetParent;
        y += node.offsetTop;
    } return y;
}


function smoothScroll(eID) {
    var startY = currentYPosition();
    var stopY = elmYPosition(eID);
    var distance = stopY > startY ? stopY - startY : startY - stopY;
    if (distance < 100) {
        scrollTo(0, stopY); return;
    }
    var speed = Math.round(distance / 100);
    if (speed >= 20) speed = 20;
    var step = Math.round(distance / 25);
    var leapY = stopY > startY ? startY + step : startY - step;
    var timer = 0;
    if (stopY > startY) {
        for ( var i=startY; i<stopY; i+=step ) {
            setTimeout("window.scrollTo(0, "+leapY+")", timer * speed);
            leapY += step; if (leapY > stopY) leapY = stopY; timer++;
        } return;
    }
    for ( var i=startY; i>stopY; i-=step ) {
        setTimeout("window.scrollTo(0, "+leapY+")", timer * speed);
        leapY -= step; if (leapY < stopY) leapY = stopY; timer++;
    }
}
















</script>

<body >
<div >
   <p> https://overcoder.net/q/47325/%D0%BF%D0%BB%D0%B0%D0%B2%D0%BD%D0%B0%D1%8F-%D0%BF%D1%80%D0%BE%D0%BA%D1%80%D1%83%D1%82%D0%BA%D0%B0-%D0%B1%D0%B5%D0%B7-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-jquery
</p>
<p>
    https://www.sitepoint.com/smooth-scrolling-vanilla-javascript/
</p>
    Метод принимает только один необязательный параметр, который задает, будет ли текущий элемент страницы перехватывать все события, вызванные дочерними элементами (значение true, используемое по умолчанию), или нет (значение false).
    Если параметр равен false, то события направляются соответствующим элементам и потом постепенно "всплывают" к родителям (обычное поведение событий).
    Метод не возвращает значения.
    Поддерживается IE начиная с 4.0
    Метод принимает только один необязательный параметр, который задает, будет ли текущий элемент страницы перехватывать все события, вызванные дочерними элементами (значение true, используемое по умолчанию), или нет (значение false).
    Если параметр равен false, то события направляются соответствующим элементам и потом постепенно "всплывают" к родителям (обычное поведение событий).
    Метод не возвращает значения.
    Поддерживается IE начиная с 4.0
    Метод принимает только один необязательный параметр, который задает, будет ли текущий элемент страницы перехватывать все события, вызванные дочерними элементами (значение true, используемое по умолчанию), или нет (значение false).
    Если параметр равен false, то события направляются соответствующим элементам и потом постепенно "всплывают" к родителям (обычное поведение событий).
    Метод не возвращает значения.
    Поддерживается IE начиная с 4.0
    Метод принимает только один необязательный параметр, который задает, будет ли текущий элемент страницы перехватывать все события, вызванные дочерними элементами (значение true, используемое по умолчанию), или нет (значение false).
    Если параметр равен false, то события направляются соответствующим элементам и потом постепенно "всплывают" к родителям (обычное поведение событий).
    Метод не возвращает значения.
    Поддерживается IE начиная с 4.0
    Метод принимает только один необязательный параметр, который задает, будет ли текущий элемент страницы перехватывать все события, вызванные дочерними элементами (значение true, используемое по умолчанию), или нет (значение false).
    Если параметр равен false, то события направляются соответствующим элементам и потом постепенно "всплывают" к родителям (обычное поведение событий).
    Метод не возвращает значения.
    Поддерживается IE начиная с 4.0
    Метод принимает только один необязательный параметр, который задает, будет ли текущий элемент страницы перехватывать все события, вызванные дочерними элементами (значение true, используемое по умолчанию), или нет (значение false).
    Если параметр равен false, то события направляются соответствующим элементам и потом постепенно "всплывают" к родителям (обычное поведение событий).
    Метод не возвращает значения.
    Поддерживается IE начиная с 4.0
    Метод принимает только один необязательный параметр, который задает, будет ли текущий элемент страницы перехватывать все события, вызванные дочерними элементами (значение true, используемое по умолчанию), или нет (значение false).
    Если параметр равен false, то события направляются соответствующим элементам и потом постепенно "всплывают" к родителям (обычное поведение событий).
    Метод не возвращает значения.
    Поддерживается IE начиная с 4.0
    Метод принимает только один необязательный параметр, который задает, будет ли текущий элемент страницы перехватывать все события, вызванные дочерними элементами (значение true, используемое по умолчанию), или нет (значение false).
    Если параметр равен false, то события направляются соответствующим элементам и потом постепенно "всплывают" к родителям (обычное поведение событий).
    Метод не возвращает значения.
    Поддерживается IE начиная с 4.0
</div>
<div class="scrollTop" >Вверх</div>
</body>
</html>